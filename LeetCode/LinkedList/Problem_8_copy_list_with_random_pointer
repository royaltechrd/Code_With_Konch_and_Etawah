# Definition for a Node.
# class Node:
#     def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):
#         self.val = int(x)
#         self.next = next
#         self.random = random

class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        cur= head
        newCopiedList=Node(0)
        newCur=newCopiedList
        
        count=0
        if head:
            count=1
        else:
            return head
        
        randomIndexes={}
        while cur!=None:
            newCur.next=Node(cur.val)
            newCur=newCur.next
            # randomIndexes.append(cur.random)
            cur=cur.next
            
        newCur=newCopiedList.next
        curRdmPos=head
        count1=1
        
        while curRdmPos:
            rdmAdd=curRdmPos.random
            temphead=head
            tempnew = newCopiedList.next
            count2=1
            while temphead:
                if rdmAdd == temphead:
                    randomIndexes[count1] = count2
                    newCur.random = tempnew
                    break
                temphead=temphead.next
                tempnew = tempnew.next
                count2 += 1
            if count1 not in randomIndexes.keys() :
                randomIndexes[count1] = None
                newCur.random = None
            randomIndexes = {}
            newCur = newCur.next
            curRdmPos=curRdmPos.next
            count1 += 1
            
        return newCopiedList.next   
        
        ################# More Optimized approach #########################
# Definition for a Node.
# class Node:
#     def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):
#         self.val = int(x)
#         self.next = next
#         self.random = random

class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        cur= head
        newCopiedList=Node(0)
        newCur=newCopiedList
        
        count=0
        if head:
            count=1
        else:
            return head
        
        
        while cur!=None:
            newCur.next=Node(cur.val)
            newCur=newCur.next
            cur=cur.next
            
        newCur=newCopiedList.next
        curRdmPos=head
        
        while curRdmPos:
            rdmAdd=curRdmPos.random
            temphead=head
            tempnew = newCopiedList.next
           
            while temphead:
                if rdmAdd == temphead:
                    newCur.random = tempnew
                    break
                temphead=temphead.next
                tempnew = tempnew.next
           
            newCur = newCur.next
            curRdmPos=curRdmPos.next
            
        return newCopiedList.next   
 ###############################################################     
class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        if head is None: return None
        mapping = {}
        cur = head
        while cur:
            mapping[cur] = Node(cur.val,None,None)
            cur = cur.next
        cur = head
        while cur:
            if cur.next:
                mapping[cur].next = mapping[cur.next]
            if cur.random:
                mapping[cur].random = mapping[cur.random]
            cur = cur.next
        return mapping[head]
