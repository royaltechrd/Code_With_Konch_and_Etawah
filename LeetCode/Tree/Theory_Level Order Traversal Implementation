###########################################################################
Implementation 1
###########################################################################

class Node():
    def __init__(self,val):
        self.val=val
        self.right=None
        self.left=None
class Queue():
    def __init__(self):
        self.queueStack=[]
    def enqueue(self,item):
        self.queueStack.insert(0,item)
    def dequeue(self):
        if not self.isEmpty():
            return self.queueStack.pop()
    def isEmpty(self):
        return len(self)==0
    def peek(self):
        if not self.isEmpty():
            return self.queueStack[-1].val
    def __len__(self):
        return self.size()
    def size(self):
        return len(self.queueStack)

class BinaryTree():
    def __init__(self,root):
        self.root=Node(root)

    def levelOrderTraversal(self):
        if not self.root:
            return
        queue = Queue()
        queue.enqueue(self.root)
        traversal = ""
        while len(queue) > 0:
            traversal += str(queue.peek()) + "-"
            node = queue.dequeue()
            if node.left:
                queue.enqueue(node.left)
            if node.right:
                queue.enqueue(node.right)

        return traversal



tree=BinaryTree(1)


tree.root.left=Node(2)
tree.root.left.left=Node(4)
tree.root.left.right=Node(5)

tree.root.right=Node(3)
tree.root.right.left=Node(6)
tree.root.right.right=Node(7)

print(tree.levelOrderTraversal())
# print(node.left.val)
